---
title: Java内存区域与内存溢出
date: 2020-11-22 14:57:25
tags: Code
---

# Java内存区域和内存溢出异常

Java和C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外的人想进去，墙内的人想出来。

### 运行时数据区域

**线程私有：**

* 程序计数器：当前线程所执行字节码的行号指示器。

* Java虚拟机栈：每个方法被执行的时候，Java虚拟机会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
* 本地方法栈：与虚拟机栈帧类似，但本地方法栈是为本地方法服务的。

**线程共享**

Java堆：Java堆是虚拟机所管理的内存最大的一块，此内存区域唯一的目的就是存放对象实例。（是垃圾收集器所管理的内存区域，所以也叫GC堆，还好没人叫他垃圾堆）。

方法区：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。（别名：非堆）。

运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量与符号引用，这部分在类加载后存放到方法区的运行时常量池中。

### 对象的创建

当Java虚拟机碰到一条字节码new指令时，先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并坚持这个类是否被加载、解析和初始化过。如果没有，先执行类加载过程。

类加载检查通过后，为新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定。相当于把一块内存从java堆分出来。

内存分配完成后，虚拟机还要将分配的内存空间都初始化为0值。

接下来，java虚拟机还要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据类型、对象的哈希码、对象的GC分代年龄等。这些信息存放于对象头当中。

从Java程序来看，还要执行构造函数。

### 对象的内存布局

对象在内存的布局可以划分为三个部分：对象头(Header)、实例数据(Instance Data)和对象填充(Padding)。

HotSpot虚拟机对象的对象头部分包括两类信息。第一类用于存储对象自身的运行时数据。第二部分是类型指针。

示例数据部分是对象真正存储的有效信息，即各种字段内容。

**对象的访问定位**

句柄访问，Java堆中可能会划分出一块内存作为句柄池，优点是稳定。

直接指针访问

