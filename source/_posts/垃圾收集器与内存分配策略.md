---
title: 垃圾收集器与内存分配策略
date: 2020-11-20 14:57:25
tags: Code
---

# 垃圾收集器与内存分配策略

### 对象已死？

引用计数法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一;当引用失效时，计数器值减一。但当两个对象相互引用时，无法删除。

~~~java
ReferenceCountingGc objA = new ReferenceCountingGc();
ReferenceCountingGc objB = new ReferenceCountingGc();
objA.instance = objB;
objB.instance = objA;
~~~

无法回收。

可达性分析：通过一系列成为"GC Roots"的跟对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，如果某个对象到GC Roots间没有任何引用链相连，则这个对象不可能在被使用。

### 垃圾收集理论

当前商业虚拟机的垃圾收集器大多遵循了分代收集，它建立在两个分代假说上:

1)弱分代假说(Weak Generational Hypothesis):绝大多数对象是朝生夕灭的。

2）强分代假说（Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象越难以消亡。

3）跨代引用假说(Intergenerational Reference Hypothsis):跨代引用假说仅占少数。

**标记-清除算法**

首先标记出需要被回收的对象，在标记完成后，统一回收掉被标记的对象。

**标记-复制算法**

将内存划分为大小相等的两块，每次只使用其中一块，然后把使用过的内存一次性清掉。

**标记-整理算法**

让所有存活对象都向所有内存空间一端移动。

