# 算法设计与分析

过程与算法是解决问题的一种方法的逐步描述。

1. 由若干条指令组成的又穷序列。
2. 每条指令的意义是确定的。
3. 具有零个或多个输入。
4. 产生若干个输出。
5. 执行时间是有限的。

算法的复杂性取决于：

1. 求解问题的规模
2. 具体的输入数据
3. 算法本身的设计

算法：确定性、有穷性、可行性、0个或多个输入、1个或多个输出。

### 递归

将相对较大规模的对象操作归结为较小规模的对象实施同样的操作。体现在递归元上。

递归元的变化应能导致算法的终止。

汉诺塔问题：

```java
void Hanoi(int n,int Fr,int To,int As){
    if(n>0){
        Hanoi(n-1,Fro,Ass,To); //将A上面的n-1个盘移至C
        Move(Fro,To);
        Hanoi(n-1,Ass,To,Fro);
    }
}
```

常见的递归形式:

1. 多变元递归
2. 多步递归
3. 嵌套递归
4. 联立递归（同时定义几个函数，它们彼此相互调用)

Hilbert图案:

```java
void A(i){
    if(i>0){
        D(i-1);x=x-h;plotint(x,y);
        A(i-1);y=y-h;ploting(x,y);
        A(i-1);x=x+h;ploting(x,y);
        B(i-1);
    }
}
```



### 动态规划

* 基本要素
  * 最优子问题
  * 重叠子问题

一个问题可用动态规划算法或者贪心算法求解的关键特征是问题的(最优子结构性质)。

按以下几个步骤进行：

1. 找出最优解的性质，并刻画其结构特征；
2. 递归地定义最优值；
3. 以自底向上的方式计算出各子结构的最优值并添入表格保存。
4. 根据计算最优值得到的信息，构造最优解。

动态规划一般分为线性动规，区域动规，树形动规，背包动规。



### 贪心算法

所作出的选择只是局部最优的。

{

初始化；

重复执行以下操作；

选择当前可以选择的最优解；

将所选择的当前解加入到问题的解；

直至满足问题求解的结束条件。

}

要证明一个整体最优解必定包含了第一个贪心选择。

**Prim算法做法**

保证连通的前提下依次选出权重较小的n-1条边。

**Kruskal算法的做法**

无回路的前提下一次选择权重较小的n-1条边。



### 回溯

**n皇后**

~~~java
Try(s){
    j=0;q=0;
    while(!q&&j<n){
        j++;
        if(Safe(s,j)){
            Record(s,j);
            if(s==n){q==1;output();}
            else Try(s+1);
            if(!q) Move-Off(s,j);
        }
    }
    return q;
}
Record(s,j){k=s-j+n-1;
B[s]=j;C[j]=0;D[s+j-1]=0;U[k]=0;}

Move-Off(s,j){
    k=s-j+n-1;
    B[s]=0;C[j]=1;D[s+j-1]=1;U[k]=1;
}
Safe(s,j){
    k=s-j+n-1;
    if(c[j]&&U[k]&&D[s+j-1])return true;
    else return false;
}
~~~

**TSP问题**

~~~java
Try(s){
    for(i=2;i<=n;i++)
        if(C>NC+C[N[s][i]]&&T[i]){
            Record(s,i);
            if(s==n)
                if(C>NC+C[N[s][l]]) TakeNewPath();
            else Try(s+1);
            Move-of(s,i);
            return;
        }
}
~~~





### 分支限界法

分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。

* 常用的两种方法
  * 优先队列法(最小耗费优先)
  * FIFO(队列式)分支限界法(广度优先)



### 概率计算

基本特征是计算具有不确定性。解也不一定是最优解。

一个问题可以采用随机选择计算的步骤。

基本特征是计算具有不确定性。

解不一定是最优解。

计算

~~~java
double Darts(int n){
    double x,y;
    int k=0;
    static RandomNumber dart;
    for(int i=1;i<=n;i++){
        x=dart.fRandom();
        y=dart.fRandom();
        if(y<=f(x)) k++;
    }
    return k/double(n);
}
~~~

模拟洗牌

~~~java
void Shuffle(Type a[],int n){
    static RandomNumber md;
    for(int i=1;i<n;i++){
        int j = md.Random(n-i+1)+i;
    }
}
~~~

模拟退火算法

~~~java
k=0;
i=i0;
t=t0;
while(不满足停止准则){
    Gen(Si);
    foreach(j Si)
        if(f(i)<f(j)) i=j;
    else if(exp(f(i) - f(j))/t)>random(0,1)) i=j;
    k=k+1;
    t=tk;
}
~~~



1975年霍兰提出了遗传算法：产生所谓的个体种群，经过复制、交叉和变异产生下一代种群。（交叉、变异、度量、选择）

(1)下列算法不是随机算法思想的是：（A）

- A.

  普里姆算法

- B.

  舍伍德算法

- C.

  蒙特卡洛算法

- D.

  拉斯维加斯算法

(2)模拟退火算法来源于固体退火原理。

(3)人工神经网络算法是一种模拟人类大脑神经网络结构的算法。



### NP完全问题

(1)k带图灵机的空间复杂性S(n)是指（A）

- A.

  k带图灵机处理所有长度为n的输入时，在k条带上所使用过的方格数的总和。

(2)下面关于NP问题说法正确的是  P类问题包含在NP类问题中

(3)所有非确定性多项式时间内可解的判定问题构成NP类问题 对

