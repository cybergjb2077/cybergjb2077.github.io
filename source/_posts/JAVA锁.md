---
title: Java锁
date: 2020-11-18 14:57:25
tags: Code
---

# JAVA锁

### 最底层

互斥锁：加锁失败后，线程会释放CPU给其他线程。

线程会阻塞。对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现。会有额外的开销成本，是两次线程上下文切换的成本。所以如果你能确定加锁的代码执行时间很短，那就不应该用互斥锁，应该用自旋锁。

自旋锁：加锁失败后，线程会忙等待，直到它拿到锁。

不会发生上下文切换，会比互斥锁快一点，开销也小一点。



### 读写锁

读写锁适用于能明确区分读操作和写操作的场景。

当**写锁**没有被线程持有时，多个线程能够并发的持有读锁。但当**读锁**被线程持有时，读写锁都会被阻塞。所以，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而写锁是共享锁。因此，读写锁的优势是**读多写少**。

读写锁的分类:

* 读优先锁
  * 线程A有读锁。线程B要获得写锁，会阻塞。线程C要写锁，获得。B要等待A和C都释放后才会获得写锁。
* 写优先锁
  * 线程A有读锁。线程B要获得写锁，会阻塞。线程C要写锁，阻塞。B要等待A释放后才会获得写锁。

分别都会导致饿死的现象，所以可以采用公平读写锁。

### 乐观锁和悲观锁

互斥锁、自旋锁、读写锁，都是悲观锁。认为多线程同时修改共享资源的概率比较高，于是容易出现冲突，所以访问共享资源前，先要上锁。

乐观锁:先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现其他线程已经修改过这个资源，则放弃本次操作。全程未加锁，故称为无锁编程。在冲突概率非常低，且加锁成本非常高的场景时，才考虑用乐观锁。

